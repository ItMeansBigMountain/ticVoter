{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar fetch_stocks = function fetch_stocks() {\n  var response, json;\n  return _regeneratorRuntime.async(function fetch_stocks$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(fetch('https://dumbstockapi.com/stock?exchanges=NYSE'));\n\n        case 2:\n          response = _context.sent;\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(response.json());\n\n        case 5:\n          json = _context.sent;\n          return _context.abrupt(\"return\", json);\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nfunction chunking(qty) {\n  fetch_stocks().then(function (arr_object) {\n    return new Promise(function _callee(resolve, reject) {\n      var newArr, lastItemIndex, newIndex;\n      return _regeneratorRuntime.async(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              lastItemIndex = arr_object.indexOf(lastItem);\n\n              if (!(lastItemIndex === arr_object.length - 1)) {\n                _context2.next = 3;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", resolve('done'));\n\n            case 3:\n              if (!lastItem) {\n                newArr = _toConsumableArray(arr_object).slice(0, qty);\n                lastItem = _toConsumableArray(newArr).pop();\n              } else {\n                newIndex = arr_object.indexOf(lastItem) + 1;\n                newArr = _toConsumableArray(arr_object).slice(newIndex, qty + newIndex);\n                lastItem = _toConsumableArray(newArr).pop();\n              }\n\n              setTimeout(function () {\n                resolve(newArr);\n              }, 1000);\n              console.log(newArr);\n              return _context2.abrupt(\"return\", newArr);\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    });\n  });\n}\n\nvar lastItem = '';\nexport var fetch_rendered_data = function fetch_rendered_data(qty) {\n  return _regeneratorRuntime.async(function fetch_rendered_data$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          return _context3.abrupt(\"return\", chunking(qty));\n\n        case 1:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"sources":["C:/Users/affan/Desktop/JavaScript/REACT/projects/ticVoter/DataServer.js"],"names":["fetch_stocks","fetch","response","json","chunking","qty","then","arr_object","Promise","resolve","reject","lastItemIndex","indexOf","lastItem","length","newArr","slice","pop","newIndex","setTimeout","console","log","fetch_rendered_data"],"mappings":";;;AAGA,IAAMA,YAAY,GAAG,SAAfA,YAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACEC,KAAK,CACxB,+CADwB,CADP;;AAAA;AACfC,UAAAA,QADe;AAAA;AAAA,2CAIFA,QAAQ,CAACC,IAAT,EAJE;;AAAA;AAIfA,UAAAA,IAJe;AAAA,2CAKZA,IALY;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAArB;;AAcA,SAASC,QAAT,CAAkBC,GAAlB,EAAuB;AACrBL,EAAAA,YAAY,GACTM,IADH,CAEI,UAACC,UAAD;AAAA,WAEE,IAAIC,OAAJ,CAAY,iBAAOC,OAAP,EAAgBC,MAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAEJC,cAAAA,aAFI,GAEYJ,UAAU,CAACK,OAAX,CAAmBC,QAAnB,CAFZ;;AAAA,oBAGNF,aAAa,KAAKJ,UAAU,CAACO,MAAX,GAAoB,CAHhC;AAAA;AAAA;AAAA;;AAAA,gDAG0CL,OAAO,CAAC,MAAD,CAHjD;;AAAA;AAIV,kBAAI,CAACI,QAAL,EAAe;AACbE,gBAAAA,MAAM,GAAG,mBAAIR,UAAJ,EAAgBS,KAAhB,CAAsB,CAAtB,EAAyBX,GAAzB,CAAT;AACAQ,gBAAAA,QAAQ,GAAG,mBAAIE,MAAJ,EAAYE,GAAZ,EAAX;AACD,eAHD,MAGO;AACCC,gBAAAA,QADD,GACYX,UAAU,CAACK,OAAX,CAAmBC,QAAnB,IAA+B,CAD3C;AAELE,gBAAAA,MAAM,GAAG,mBAAIR,UAAJ,EAAgBS,KAAhB,CAAsBE,QAAtB,EAAgCb,GAAG,GAAGa,QAAtC,CAAT;AACAL,gBAAAA,QAAQ,GAAG,mBAAIE,MAAJ,EAAYE,GAAZ,EAAX;AACD;;AACDE,cAAAA,UAAU,CAAC,YAAM;AACfV,gBAAAA,OAAO,CAACM,MAAD,CAAP;AACD,eAFS,EAEP,IAFO,CAAV;AAGAK,cAAAA,OAAO,CAACC,GAAR,CAAYN,MAAZ;AAfU,gDAgBHA,MAhBG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAZ,CAFF;AAAA,GAFJ;AAuBD;;AAGD,IAAIF,QAAQ,GAAG,EAAf;AACA,OAAO,IAAMS,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAMjB,GAAN;AAAA;AAAA;AAAA;AAAA;AAAA,4CAAcD,QAAQ,CAACC,GAAD,CAAtB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAA5B","sourcesContent":["\r\n\r\n// HTTP REQUEST\r\nconst fetch_stocks = async () => {\r\n  let response = await fetch(\r\n    'https://dumbstockapi.com/stock?exchanges=NYSE'\r\n  );\r\n  let json = await response.json();\r\n  return json;\r\n}\r\n\r\n\r\n\r\n\r\n// splits fetched json data array into chunks that are going to be requested whenever user scrolls\r\n\r\n\r\nfunction chunking(qty) {\r\n  fetch_stocks()\r\n    .then(\r\n      (arr_object) =>\r\n        // create promise to chunk qty of stocks to render\r\n        new Promise(async (resolve, reject) => {\r\n          let newArr;\r\n          const lastItemIndex = arr_object.indexOf(lastItem);\r\n          if (lastItemIndex === arr_object.length - 1) return resolve('done');\r\n          if (!lastItem) {\r\n            newArr = [...arr_object].slice(0, qty);\r\n            lastItem = [...newArr].pop();\r\n          } else {\r\n            const newIndex = arr_object.indexOf(lastItem) + 1;\r\n            newArr = [...arr_object].slice(newIndex, qty + newIndex);\r\n            lastItem = [...newArr].pop();\r\n          }\r\n          setTimeout(() => {\r\n            resolve(newArr);\r\n          }, 1000);\r\n          console.log(newArr)\r\n          return newArr\r\n        })\r\n    )\r\n}\r\n\r\n\r\nlet lastItem = '';\r\nexport const fetch_rendered_data = async qty =>  chunking(qty) \r\n  // fetch stocks promise\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}